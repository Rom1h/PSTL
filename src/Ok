import LeanMachines.Event.Basic
import LeanMachines.Event.Ordinary
import LeanMachines.Event.Convergent
import LeanMachines.NonDet.Ordinary

-- CONTEXT
structure BoundedCtx where
  -- CONSTANTS
  maxCount : Nat  -- type_maxCount : maxCount ∈ ℕ
  -- AXIOMS
  prop_maxCount : maxCount > 0  -- prop_maxCount   :    maxCount > 0
-- END (CONTEXT)

-- MACHINE
structure Bounded /-SEES-/ (ctx : BoundedCtx) where
  -- VARIABLES
  count : Nat -- type_count : count ∈ ℕ

namespace Bounded

-- inv_count_bounded : count ≤ maxCount
@[simp]
def inv_count_bounded (m : Bounded ctx) : Prop :=
  m.count ≤ ctx.maxCount

-- A générer explicitement
@[simp]
def Default : Bounded ctx :=
  {count := default }

-- MACHINE Bounded SEES BoundedCtx
instance: Machine BoundedCtx (Bounded ctx) where
  context := ctx
  -- INVARIANTS
  invariant m := (inv_count_bounded m)
                 -- ∧ (inv_etc_  m)  ∧  etc.

  default := Default

/- EVENTS -/

-- INITIALISATION
def Initialisation : InitEvent (Bounded ctx) Unit Unit :=
  newInitEvent'' {  -- prime-prime  because in/out types are Unit Unit
    init _ := { count := 0 } -- init1 : count ≔ 0 
    safety _ := by sorry  -- always sorry (after by)
  }

-- Incr STATUS Ordinary

-- grd1 : count < maxCount
@[simp]
def Incr.guard_grd1 (m : Bounded ctx) : Prop :=
  m.count < ctx.maxCount

-- action
@[simp]
def Incr.action (m : Bounded ctx) : Bounded ctx :=
  { count := m.count + 1 } -- act1 : count ≔ count + 1


def Incr : OrdinaryEvent (Bounded ctx) Unit Unit :=
  newEvent'' {
    guard m := Incr.guard_grd1 m
               -- ∧ guard_grd2 m ...
    action m _ := Incr.action m 
    safety m := by sorry
  }